install.packages(c("AICcmodavg", "BH", "DBI", "Formula", "Hmisc", "MASS", "MasterBayes", "Matrix", "R6", "Rcpp", "RcppArmadillo", "RcppEigen", "Rvmmin", "ade4", "ape", "assertthat", "backports", "boot", "checkmate", "circular", "cluster", "corpcor", "cowplot", "cubature", "data.table", "deldir", "digest", "dplyr", "evaluate", "fastmatch", "fitdistrplus", "foreign", "formatR", "gamlss", "gamlss.dist", "gdata", "goftest", "gridExtra", "htmlTable", "htmltools", "httpuv", "igraph", "irlba", "jsonlite", "knitr", "lattice", "lme4", "lmomco", "markdown", "mgcv", "mvtnorm", "nlme", "pegas", "phangorn", "polyclip", "poppr", "poweRlaw", "pscl", "reshape", "rmarkdown", "rpart", "scales", "segmented", "seqinr", "shiny", "sourcetools", "sp", "spatstat", "spdep", "stringi", "stringr", "survival", "tibble", "unmarked", "vegan", "viridis", "zoo"))
install.packages(c("AICcmodavg", "BH", "DBI", "Formula", "Hmisc", "MASS", "MasterBayes", "Matrix", "R6", "Rcpp", "RcppArmadillo", "RcppEigen", "Rvmmin", "ade4", "ape", "assertthat", "backports", "boot", "checkmate", "circular", "cluster", "corpcor", "cowplot", "cubature", "data.table", "deldir", "digest", "dplyr", "evaluate", "fastmatch", "fitdistrplus", "foreign", "formatR", "gamlss", "gamlss.dist", "gdata", "goftest", "gridExtra", "htmlTable", "htmltools", "httpuv", "igraph", "irlba", "jsonlite", "knitr", "lattice", "lme4", "lmomco", "markdown", "mgcv", "mvtnorm", "nlme", "pegas", "phangorn", "polyclip", "poppr", "poweRlaw", "pscl", "reshape", "rmarkdown", "rpart", "scales", "segmented", "seqinr", "shiny", "sourcetools", "sp", "spatstat", "spdep", "stringi", "stringr", "survival", "tibble", "unmarked", "vegan", "viridis", "zoo"))
install.packages(c("AICcmodavg", "BH", "DBI", "Formula", "Hmisc", "MASS", "MasterBayes", "Matrix", "R6", "Rcpp", "RcppArmadillo", "RcppEigen", "Rvmmin", "ade4", "ape", "assertthat", "backports", "boot", "checkmate", "circular", "cluster", "corpcor", "cowplot", "cubature", "data.table", "deldir", "digest", "dplyr", "evaluate", "fastmatch", "fitdistrplus", "foreign", "formatR", "gamlss", "gamlss.dist", "gdata", "goftest", "gridExtra", "htmlTable", "htmltools", "httpuv", "igraph", "irlba", "jsonlite", "knitr", "lattice", "lme4", "lmomco", "markdown", "mgcv", "mvtnorm", "nlme", "pegas", "phangorn", "polyclip", "poppr", "poweRlaw", "pscl", "reshape", "rmarkdown", "rpart", "scales", "segmented", "seqinr", "shiny", "sourcetools", "sp", "spatstat", "spdep", "stringi", "stringr", "survival", "tibble", "unmarked", "vegan", "viridis", "zoo"))
install.packages("anim.plots")
library("anim.plots", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
anim.plot(-x^2, times = 1:30, n=100,speed = 5, from=-1,to=1)
x<-1:5
anim.plot(-x^2, times = 1:30, n=100,speed = 5, from=-1,to=1)
library(anim.plots)
library(anim.plots)
x<- rep(1:100/10,10)
y<- -x^2
anim.plot(x,y,times = 1:10)
x <- rep(1:100/10, 10)
times <- rep(1:10, each=100)
y <- sin(x*times/4)
anim.plot(x,y,times, type="l", col="orange", lwd=2)
anim.plot(x,y,times, type="l", lwd = 2)
anim.plot(x,y,times=2, type="l", lwd = 2)
anim.plot(x,y,times=1, type="l", lwd = 2)
gr1<-anim.plot(x,y,times=1, type="l", lwd = 2)
gr1
gr1
anim.plot(x,y,times=1, type="l", lwd = 2)
anim.plot(x,y,times=10, type="l", lwd = 2)
anim.plot(x,y,times=5, type="l", lwd = 2)
anim.plot(x,y,times=10, type="l", lwd = 2)
install.packages("flowCore")
install.packages("NPflow")
install.packages("OpenCyto")
install.packages(c("Rcpp", "RcppArmadillo", "adegenet", "backports", "checkmate", "data.table", "doParallel", "dplyr", "lme4", "pscl", "spatstat"))
install.packages("installr")
install.packages("instaR")
library("instaR", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
remove.packages("instaR")
install.packages("ade4")
install.packages("ggplot2")
install.packages("dplyr")
## try http:// if https:// URLs are not supported
source("https://bioconductor.org/biocLite.R")
biocLite()
require(BiocInstaller) biocLite("openCyto")
require(BiocInstaller)
biocLite("openCyto")
ws<-openWorkspace("data/workspace/080 batch 0882.xml")
library("Biobase", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
library("BiocInstaller", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
require(BiocInstaller)
biocLite("openCyto")
library(Biobase)
library(BiocGenerics)
library(BiocInstaller)
require(BiocInstaller)
biocLite("openCyto")
biocLite("openCyto")
install.packages("devtools")
install_github("RGLab/opencytoCL")
defaults write org.R-project.R force.LANG en_US.UTF-8
biocLite("openCyto")
system('defaults write org.R-project.R force.LANG en_US.UTF-8')
library(Biobase)
library(BiocGenerics)
library(BiocInstaller)
require(BiocInstaller)
biocLite("openCyto")
install.packages("lme4")
system('defaults write org.R-project.R force.LANG en_US.UTF-8')
system('defaults write org.R-project.R force.LANG en_US.UTF-8')
load("~/Documents/Proyectos/Chamaedorea/Chamedorea pinnatifrons/EstadÃ­stica/Fenologia pinnatifrons.RData")
library(ggplot2)
library(cowplot) #this library is to save the figure
#fitting the distribution of fruit production
library(fitdistrplus)
library(MASS)
library(lmtest)
library(lme4)
library(Hmisc)
correlaciones
library(Hmisc) #rcorr
RS <- read.csv("ER pinna.csv")
correlations <- RS[,3:14] #matrix for correlations
rcorr(as.matrix(correlations),type = "spearman")
#negative binomial model with inflorescences nested within individuals as random factors
#  I extracted the theta value from the fitting of the fruit production distribution
mod1c <- glmer(data=RS,fruts~height+leaves+malecl+femcl+femfiv+
census+sincH+sincM+nofl+(1|id/infl), family=(negative.binomial(mod1b$theta)))
# negative binomial model WITHOUT inflorescences nested within individuals as random factors
mod1b <- glm.nb(data=RS,fruts~height+leaves+malecl+femcl+femfiv+
census+sincM+sincH+nofl)
library(Hmisc) #rcorr
library(MASS) #glm.nb
library(lme4) #glmer
library(pscl) #zeroinfl
library(lmtest) #step
# Model with all the variables with a Poisson distribution
mod1a <- glmer(data=RS,fruts~height+leaves+malecl+femcl+femfiv+
census+sincH+sincM+nofl+(1|id/infl),family=poisson,control=glmerControl(optimizer="bobyqa"))
# negative binomial model WITHOUT inflorescences nested within individuals as random factors
mod1b <- glm.nb(data=RS,fruts~height+leaves+malecl+femcl+femfiv+
census+sincM+sincH+nofl)
#negative binomial model with inflorescences nested within individuals as random factors
#  I extracted the theta value from the fitting of the fruit production distribution
mod1c <- glmer(data=RS,fruts~height+leaves+malecl+femcl+femfiv+
census+sincH+sincM+nofl+(1|id/infl), family=(negative.binomial(mod1b$theta)))
RS <- read.csv("ER pinna.csv")
frutsno <-RS$nofl-RS$fruts
RS[,3:14]<-scale(RS[,3:14])
RS <- cbind(RS, frutsno)
# Model with all the variables with a Poisson distribution
mod1a <- glmer(data=RS,fruts~height+leaves+malecl+femcl+femfiv+
census+sincH+sincM+nofl+(1|id/infl),family=poisson,control=glmerControl(optimizer="bobyqa"))
# negative binomial model WITHOUT inflorescences nested within individuals as random factors
mod1b <- glm.nb(data=RS,fruts~height+leaves+malecl+femcl+femfiv+
census+sincM+sincH+nofl)
#negative binomial model with inflorescences nested within individuals as random factors
#  I extracted the theta value from the fitting of the fruit production distribution
mod1c <- glmer(data=RS,fruts~height+leaves+malecl+femcl+femfiv+
census+sincH+sincM+nofl+(1|id/infl), family=(negative.binomial(mod1b$theta)))
AIC(mod1a,mod1b,mod1c)
summary(mod1c)
mod1e<-update(mod1c, .~. -sincH)
mod1e<-update(mod1c, .~. -sincM)
AIC(mod1e,mod1c)
summary(mod1e)
correlations <- RS[,3:14] #matrix for correlations
rcorr(as.matrix(correlations),type = "spearman")
# Model with all the variables with a Poisson distribution
mod1a <- glmer(data=RS,fruts~height+leaves+malecl+femcl+
census+sincH+sincM+nofl+(1|id/infl),family=poisson,control=glmerControl(optimizer="bobyqa"))
# negative binomial model WITHOUT inflorescences nested within individuals as random factors
mod1b <- glm.nb(data=RS,fruts~height+leaves+malecl+femcl+
census+sincM+sincH+nofl)
#negative binomial model with inflorescences nested within individuals as random factors
#  I extracted the theta value from the fitting of the fruit production distribution
mod1c <- glmer(data=RS,fruts~height+leaves+malecl+femcl+
census+sincH+sincM+nofl+(1|id/infl), family=(negative.binomial(mod1b$theta)))
AIC(mod1a,mod1b,mod1c)
summary(mod1c)
mod1e<-update(mod1c, .~. -sincM)
summary(mod1e)
AIC(mod1e,mod1c)
anova(mod1e,mod1c)
mod1f <- update(mod1e, .~. -leaves)
anova(mod1f,mod1e)
AIC(mod1f,mod1e)
summary(mod1f)
mod1g <- update(mod1f, .~. -sincH)
anova(mod1f,mod1g)
AIC(mod1g,mod1f)
summary(mod1g)
mod1h <- update(mod1g, .~. -malecl)
anova(mod1h,mod1g)
AIC(mod1h,mod1g)
summary(mod1h)
summary(mod1h)
mod1i <- update(mod1h, .~. -femcl)
anova(mod1i,mod1h)
AIC(mod1i,mod1h)
summary(mod1i)
#with random effect and binomial distribution
mod2a <- glmer(data=RS,cbind(fruts,frutsno)~height+leaves+malecl+femcl+census+
sincM+sincH+(1|id/infl),family=binomial, control=glmerControl(optimizer="bobyqa"))
#without random effects
mod2b <- glm(data=RS,cbind(fruts,frutsno)~height+leaves+malecl+femcl+
census+sincM+sincH,family=binomial)
anova(mod2a,mod2b)
AIC(mod2a,mod2b)
summary(mod2a)
#model without sincH
mod2c <- update(mod2a, .~. -sincM)
anova(mod2a,mod2c)
AIC(mod2a,mod2c)
summary(mod2c)
step(mod2a)
#model without sincH
mod2c <- update(mod2a, .~. -sincM)
mod2d <- update(mod2c, .~. -femfiv)
AIC(mod2c,mod2d)
summary(mod2c)
mod2d <- update(mod2c, .~. -sincH)
anova(mod2c,mod2d)
AIC(mod2c,mod2d)
summary(mod2d)
summary(mod1i)
library(lme4) #glmer
#negative binomial model with inflorescences nested within individuals as random factors
#  I extracted the theta value from the fitting of the fruit production distribution
mod1c <- glmer(data=RS,fruts~height+leaves+malecl+femcl+
census+sincM+nofl+(1|id/infl), family=(negative.binomial(0.2996707)))
mod1e<-update(mod1c, .~. -census:sincM)
summary(mod1c)
mod1e<-update(mod1c, .~. -leaves)
summary(mod1e)
mod1f <- update(mod1e, .~. -sincM)
summary(mod1f)
mod1g <- update(mod1f, .~. -malecl)
summary(mod1g)
mod1h <- update(mod1g, .~. -femcl)
summary(mod1h)
citation()
RS <- read.csv("ER pinna.csv")
cor.test(RS$height,RS$fruts)
cor.test(RS$nofl,RS$fruts)
cor.test(RS$census,RS$fruts)
library(lme4) #glmer
#negative binomial model with inflorescences nested within individuals as random factors
#  I extracted the theta value from the fitting of the fruit production distribution
mod1c <- glmer(data=RS,fruts~height+leaves+malecl+femcl+
census+sincM+nofl+(1|id/infl), family=(negative.binomial(0.2996707)))
summary(mod1c)
anova(mod1e,mod1c)
AIC(mod1a,mod1b,mod1c) #model 1c is the chosen one because it makes the most biological sense
AIC(mod1e,mod1c)
AIC(mod1f,mod1e)
AIC(mod1g,mod1f)
AIC(mod1h,mod1g)
anova(mod1e,mod1c)
anova(mod1f,mod1e)
mod1e<-update(mod1c, .~. -leaves)
anova(mod1e,mod1c)
mod1f <- update(mod1e, .~. -sincM)
anova(mod1f,mod1e)
mod1e<-update(mod1c, .~. -leaves)
anova(mod1e,mod1c)
mod1f <- update(mod1e, .~. -sincM)
anova(mod1f,mod1e)
mod1g <- update(mod1f, .~. -malecl)
anova(mod1f,mod1g)
mod1h <- update(mod1g, .~. -femcl)
anova(mod1h,mod1g)
summary(mod1c)
summary(mod1e)
summary(mod1f)
summary(mod1g)
library(circular)
windc <- circular(wind, type=("angles"), units = ("radians"), template = ("geographics"))
plot(wind, pch=16, xlab="Observaciones", ylab= "direcciÃ³n del viento (en radianes)")
plot(windc, cex=1, bin=720, stack=TRUE, sep=0.035, shrink=1.2, axes = F)
lepe <- read.delim("Lepechinia.txt")
pernettya <- read.delim("Pernettya.txt")
lepeC <- circular(lepe, type = ("angles"), units=("degrees"), template=("none"), modulo = ("asis"), rotation=("clock"))
pernettyaC <- circular(pernettya, type = ("angles"), units=("degrees"), template=("none"), modulo = ("asis"), rotation=("clock"))
rose.diag(lepeC, bins=11.5, col="darkorchid1", cex=1.5, prop=1.4, axes = F)
rose.diag(pernettyaC, bins=11.5, col="ivory", border=1, cex=1.5, prop=1.4, axes=F, add=T)
rose.diag(lepeC, bins=11.5, col="darkorchid1", cex=1.5, prop=1.4, axes = F)
rose.diag(pernettyaC, bins=11.5, col="ivory", border=1, cex=1.5, prop=1.4, axes=F, add=T)
rose.diag(lepeC, bins=11.5, col="darkorchid1", cex=1.5, prop=1.4, axes = F)
rose.diag(pernettyaC, bins=11.5, col="ivory", border=1, cex=1.5, prop=1.4, axes=F, add=T)
axis.circular(at=circular(seq(0, 11*pi/6,pi/6)), labels=c("E","D", "N","O","S","A","J","J","M","A","M","F"), cex=1.5)
rose.diag(lepeC, bins=11.5, col="darkorchid1", cex=1.5, prop=1.4, axes = F)
rose.diag(pernettyaC, bins=11.5, col="ivory", border=1, cex=1.5, prop=1.4, axes=F, add=T)
axis.circular(at=circular(seq(0, 11*pi/6,pi/6)), labels=c("E","D", "N","O","S","A","J","J","M","A","M","F"), cex=1.5)
rho.circular(lepeC)
rho.circular(x=lepeC)
rho.circular(x=lepeC,na.rm = TRUE)
rho.circular(x=pernettyaC,na.rm = TRUE)
source('~/.active-rstudio-document', echo=TRUE)
knitr::opts_chunk$set(echo = TRUE)
getwd
setwd("~/GitHub/QB2019_Rios/2.Worksheets/5.AlphaDiversity/")
library(vegan)
RACresults <- radfit(site1)
library(vegan)
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
S.obs(BCI)
library(vegan)
S.obs <- function(x = ""){
rowSums(x > 0) * 1
}
data(BCI)
S.obs(BCI)
C <- function(x = ""){
1 - (sum(x == 1) / rowSums(x))
}
soilbac <- read.table("~/GitHub/QB2019_Rios/2.Worksheets/5.AlphaDiversity/data/soilbac.txt",header = T, row.names = 1)
soilbac <- read.table("~/GitHub/QB2019_Rios/2.Worksheets/5.AlphaDiversity/data/soilbac.txt",header = T, row.names = 1)
soilbac.t <- as.data.frame(t(soilbac))
soilbac1 <- soilbac.t[1,]
S.chao1 <- function(x = ""){
S.obs(x) + (sum(x == 1)^2) / (2 * sum(x == 2))
}
S.chao1(soilbac1)
S.chao2 <- function(site = "", SbyS = ""){
SbyS = as.data.frame(SbyS)
x = SbyS[site,]
SbyS.pa <- (SbyS > 0) * 1 #convert the SbyS to presence/absence
Q1 = sum(colSums(SbyS.pa) == 1) #species observed once
Q2 = sum(colSums(SbyS.pa) == 2) #species observed twice
S.chao2 = S.obs(x) + (Q1^2)/(2 * Q2)
return(S.chao2)
}
S.chao2(SbyS = soilbac, site = soilbac[1])
S.chao2 <- function(site = "", SbyS = ""){
SbyS = as.data.frame(SbyS)
x = SbyS[site,]
SbyS.pa <- (SbyS > 0) * 1 #convert the SbyS to presence/absence
Q1 = sum(colSums(SbyS.pa) == 1) #species observed once
Q2 = sum(colSums(SbyS.pa) == 2) #species observed twice
S.chao2 = S.obs(x) + (Q1^2)/(2 * Q2)
return(S.chao2)
}
S.chao2(SbyS = soilbac, site = soilbac[,1])
S.chao2(SbyS = soilbac, site = soilbac)
S.chao2(SbyS = soilbac, site = soilbac[3])
S.chao2(SbyS = soilbac, site = as.list(soilbac[,3]))
soilbac <- read.table("~/GitHub/QB2019_Rios/2.Worksheets/5.AlphaDiversity/data/soilbac.txt",header = T, row.names = 1)
soilbac.t <- as.data.frame(t(soilbac))
soilbac1 <- soilbac.t[1,]
S.chao1 <- function(x = ""){
S.obs(x) + (sum(x == 1)^2) / (2 * sum(x == 2))
}
S.chao1(soilbac1)
S.chao2 <- function(site = "", SbyS = ""){
SbyS = as.data.frame(SbyS)
x = SbyS[site,]
SbyS.pa <- (SbyS > 0) * 1 #convert the SbyS to presence/absence
Q1 = sum(colSums(SbyS.pa) == 1) #species observed once
Q2 = sum(colSums(SbyS.pa) == 2) #species observed twice
S.chao2 = S.obs(x) + (Q1^2)/(2 * Q2)
return(S.chao2)
}
S.Ace <- function(x ="", thresh = 10){
x <- x[x>0]
S.abund <- length(which(x > thresh))
S.rare <- length(which (x <= thresh))
singlt <- length(which (x == 1))
N.rare <- sum(x[which(x <= thresh)])
C.ace <- 1 - (singlt / N.rare)
i <- c(1:thresh)
count <- function(i, y){
length(y[y == i])
}
a.1 <- sapply(i, count, x)
f.1 <- (i * (i - 1)) * a.1
G.ace <- (S.rare/C.ace)*(sum(f.1)/(N.rare*(N.rare-1)))
S.ace <- S.abund + (S.rare/C.ace) + (singlt/C.ace) * max(G.ace,0)
return(S.ace)
}
S.ace(soilbac1)
S.ace(soilbac)
S.ace(soilbac1)
S.ace(soilbac.t)
S.ace(soilbac[,1])
S.ace(soilbac[1])
S.Ace <- function(x ="", thresh = 10){
x <- x[x>0]
S.abund <- length(which(x > thresh))
S.rare <- length(which (x <= thresh))
singlt <- length(which (x == 1))
N.rare <- sum(x[which(x <= thresh)])
C.ace <- 1 - (singlt / N.rare)
i <- c(1:thresh)
count <- function(i, y){
length(y[y == i])
}
a.1 <- sapply(i, count, x)
f.1 <- (i * (i - 1)) * a.1
G.ace <- (S.rare/C.ace)*(sum(f.1)/(N.rare*(N.rare-1)))
S.ace <- S.abund + (S.rare/C.ace) + (singlt/C.ace) * max(G.ace,0)
return(S.ace)
}
S.ace(soilbac[1])
S.Ace <- function(x ="", thresh = 10){
x <- x[x>0]
S.abund <- length(which(x > thresh))
S.rare <- length(which (x <= thresh))
singlt <- length(which (x == 1))
N.rare <- sum(x[which(x <= thresh)])
C.ace <- 1 - (singlt / N.rare)
i <- c(1:thresh)
count <- function(i, y){
length(y[y == i])
}
a.1 <- sapply(i, count, x)
f.1 <- (i * (i - 1)) * a.1
G.ace <- (S.rare/C.ace)*(sum(f.1)/(N.rare*(N.rare-1)))
S.ace <- S.abund + (S.rare/C.ace) + (singlt/C.ace) * max(G.ace,0)
return(S.ace)
}
S.Ace(soilbac[1])
S.Ace(soilbac)
S.chao2(SbyS = soilbac, site = soilbac[1])
S.Ace(soilbac[1])
S.chao1(soilbac1)
S.Ace(soilbac1)
soilbac.S <- S.obs(soilbac.t)
soilbac.S <- S.obs(soilbac.t)
min.N <- min(rowSums(soilbac.t))
S.rarefy <- rarefy(x = soilbac.t, sample = min.N, se = TRUE)
rarecurve(x = soilbac.t, step=20, col = "blue",cex = 0.6, las=1)
abline(0, 1, col= "red")
text(1500, 1500, "1:1", pos = 2, col = "red")
RAC <- function(x = ""){
x = as.vector(x)
x.ab = x[x > 0]
x.ab.ranked = x.ab[order(x.ab, decreasing = TRUE)]
return(x.ab.ranked)
}
plot.new()
site1 <- BCI[1,]
rac <- RAC(x = site1)
ranks <- as.vector(seq(1, length(rac)))
opar <- par(no.readonly = TRUE)
par(mar = c(5.1, 5.1, 4.1, 2.1))
plot(ranks, log(rac), type = "p", axes = F,
xlab = "Rank in abundance", ylab = "Abundance",
las = 1, cex.lab = 1.4, cex.axis = 1.25)
box()
box()
axis(side = 1, labels = T, cex.axis = 1.25)
RAC <- function(x = ""){
x = as.vector(x)
x.ab = x[x > 0]
x.ab.ranked = x.ab[order(x.ab, decreasing = TRUE)]
return(x.ab.ranked)
}
plot.new()
site1 <- BCI[1,]
rac <- RAC(x = site1)
ranks <- as.vector(seq(1, length(rac)))
opar <- par(no.readonly = TRUE)
par(mar = c(5.1, 5.1, 4.1, 2.1))
plot(ranks, log(rac), type = "p", axes = F,
xlab = "Rank in abundance", ylab = "Abundance",
las = 1, cex.lab = 1.4, cex.axis = 1.25)
axis(side = 1, labels = T, cex.axis = 1.25)
axis(side = 2, las = 1, cex.axis = 1.25,
labels = c(1,2,5,10,20), at = log(c(1,2,5,10,20)))
RAC <- function(x = ""){
x = as.vector(x)
x.ab = x[x > 0]
x.ab.ranked = x.ab[order(x.ab, decreasing = TRUE)]
return(x.ab.ranked)
}
plot.new()
site1 <- BCI[1,]
rac <- RAC(x = site1)
ranks <- as.vector(seq(1, length(rac)))
opar <- par(no.readonly = TRUE)
par(mar = c(5.1, 5.1, 4.1, 2.1))
plot(ranks, log(rac), type = "p", axes = F,
xlab = "Rank in abundance", ylab = "Abundance",
las = 1, cex.lab = 1.4, cex.axis = 1.25)
box()
axis(side = 1, labels = T, cex.axis = 1.25)
axis(side = 2, las = 1, cex.axis = 1.25,
labels = c(1,2,5,10,20), at = log(c(1,2,5,10,20)))
par <- opar
SimpE <- function(x = ""){
S <- S.obs(x)
x = as.data.frame(x)
D <- diversity(x, "inv")
E <- (D)/S
return(E)
}
SimpE(site1)
ShanH <- function(x = ""){
H = 0
for (n_1 in x){
if(n_1 > 0){
p = n_1 / sum(x)
H = H - p*log(p)
}
}
return(H)
}
ShanH(site1)
diversity(site1, index = "shannon")
SimpD <- function(x = ""){
D = 0
N = sum(x)
for (n_i in x){
D = D + (n_i^2)/(N^2)
}
return(D)
}
D.inv <- 1/SimpD(site1)
D.sub <- 1-SimpD(site1)
diversity(site1, "inv")
diversity(site1, "simp")
SimpD <- function(x = ""){
D = 0
N = sum(x)
for (n_i in x){
D = D + (n_i^2)/(N^2)
}
return(D)
}
D.inv <- 1/SimpD(site1)
D.sub <- 1-SimpD(site1)
D.inv
D.sub
diversity(site1, "inv")
diversity(site1, "simp")
rac <- as.vector(sit1[site1 > 0])
rac <- as.vector(site1[site1 > 0])
invD <- diversity(rac, "inv")
invD
Fisher <- fisher.alpha(rac)
Fisher
RACresults <- radfit(site1)
RACresults
plot.new()
plot(RACresults, las = 1, cex.lab = 1.4, cex.axis = 1.25)
S.chao2(SbyS = soilbac, site = soilbac[1])
S.chao2(SbyS = soilbac, site = soilbac1)
S.chao2(SbyS = soilbac1, site = soilbac1)
S.chao2(SbyS = soilbac, site = soilbac[,1])
S.chao2(SbyS = soilbac, site = soilbac[,1:3])
setwd("~/GitHub/QB2019_Rios/2.Worksheets/5.AlphaDiversity/")
